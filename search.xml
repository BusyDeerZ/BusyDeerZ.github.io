<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习之Numpy]]></title>
    <url>%2F2019%2F03%2F09%2Fp4%2F</url>
    <content type="text"><![CDATA[1.啥是 NumpyNumpy 是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 Numpy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象ndarray 广播功能函数 整合C/C++/Fortran 代码的工具 线性代数、傅里叶变化、随机数生成等功能 2.Numpy 用法1关于打印与查看 123456import numpy as npworld_alcohol = np.genfromtxt("world_alcohol.txt", delimiter=",",dtype=str)#导入txt文件，格式：文件位置+文件名+拓展名、分隔符、读入格式print(type(world_alcohol))#ndarray 二维矩阵print(world_alcohol)print (help(np.genfromtxt))#帮助文档 关于 Numpy 数组 123456vector = np.array([5, 10, 15, 20]) #一维matrix = numpy.array([[5, 10, 15], [20, 25, 30], [35, 40, 45]])#二维--矩阵a = np.array([[[1,1,1],[2,3,1],[3,4,5]]]) #三维数组print (vector)print (matrix)print (a) 打印结果分别为： [5 10 15 20] [[5 10 15][20 25 30][35 40 45]] [[[1 1 1][2 3 1][3 4 5]]] Numpy 中关于维度的理解 关于维度的大小 1234vector = np.array([1, 2, 3, 4])print(vector.shape)#当前ndarray的结构，一维四个元素matrix = np.array([[5, 10, 15], [20, 25, 30]])#矩阵，两行三列print(matrix.shape) 打印结果： (4,) (2,3) 关于数据类型相同 123import numpynumbers = numpy.array([1, 2, 3, 4])#里面的元素必定是相同的数据类型numbers.dtype 打印结果： dtype(&#39;int32&#39;) 关于数据类型转换 1234import numpynumbers = numpy.array([1.0, 2, 3, 4])#里面的元素必定是相同的数据类型print (numbers)numbers.dtype#会自动进行数据类型 打印结果： [1. 2. 3. 4.] dtype(&#39;float64&#39;) 关于读入数据格式 12world_alcohol = numpy.genfromtxt("world_alcohol.txt", delimiter=",", dtype="U75", skip_header=1) #将数据格式转化为u'xxx'的格式print(world_alcohol) 打印结果： [[u&#39;1986&#39; u&#39;Western Pacific&#39;....].[...]...] 关于选择性打印数据 123456matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])print(matrix[1:3,0:2]) 打印结果： [[20 25][35 40]] 3.Numpy 用法2判断元素是否在矩阵内 12345import numpyvector = numpy.array([5, 10, 15, 20])equal_to_ten = (vector == 10) #判断是否存在一个值为10 ，对其中每个元素都会进行判断并会自动返回结果print equal_to_tenprint (vector[equal_to_ten]) #以布尔值为索引，并进行返回 打印结果： [False,True,False,False] [10] 类型转换 123456vector = numpy.array(["1", "2", "3"])#都为string值print vector.dtypeprint vectorvector = vector.astype(float)#将其进行值类型转换，转换成floatprint vector.dtypeprint vector 打印结果： |S1 [&#39;1&#39; &#39;2&#39; &#39;3&#39;] float64 [1. 2. 3.] 求平均 1234567891011world_alcohol = numpy.genfromtxt("world_alcohol.txt", delimiter=",")#print world_alcoholis_value_empty = numpy.isnan(world_alcohol[:,4]) #判断是否为空#print is_value_emptyworld_alcohol[is_value_empty, 4] = '0' #将nan用0替代alcohol_consumption = world_alcohol[:,4]alcohol_consumption = alcohol_consumption.astype(float) #类型转换total_alcohol = alcohol_consumption.sum() #求和average_alcohol = alcohol_consumption.mean() #求平均print total_alcoholprint average_alcohol 打印结果： 1137.78 1.14006 4.Numpy 用法3构建矩阵 1234import numpy as npprint (np.arange(15)) #打印出0-14向量a = np.arange(15).reshape(3, 5) #将0-14创建成3行5列的矩阵a 打印结果： [0 1 2 3 ... 14] array([[0, 1, 2, 3, 4],[5, 6, 7, 8, 9],[10, 11, 12, 13, 14]]) 打印维数 1a.ndim #维数 打印结果： 2 矩阵内数的类型 1a.dtype.name #矩阵内数的类型 打印结果： &#39;int32&#39; 矩阵内元素的总和 1a.size #整个矩阵元素总数 打印结果： 15 零矩阵 1np.zeros ((3,4)) #初始化3行4列的0矩阵 ，传入的是元组的格式，没有指定类型默认为float类型 打印结果： array([[0., 0., 0., 0.,],[0., 0., 0., 0.],[0., 0., 0., 0.]]) 一矩阵 1np.ones( (2,3,4), dtype=np.int32 ) #构造2*3*4的三维全1数组 打印结果： array([[[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]],[[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]]]) 构造ndarray 1np.arange( 10, 30, 5 ) #起始值为10 ，步长为5，终值30【取不到】 打印结果： array([10, 15, 20, 25]) 构造随机数组 1np.random.random((2,3)) #进入random模块下的random函数构造2行3列的矩阵【-1，1】上的随机值 打印结果： array([[ 0.40130659, 0.45452825, 0.79776512],[0.63220592, 0.74591134, 0.64130737]]) 规定范围内平均取5个数 12import numpy as npnp.linspace(0,5,5) #在0-5【5可取】的范围内取5个数 打印结果： array([0. , 1.25, 2.5 , 3.75, 5. ]) linspace 与 arange 的区别：前者终值可取，后者终值不可取 linspace 与arange 的对比 12345import numpy as npa = np.linspace(20,50,4)b = np.arange(20,50,10)print (a)print (b) 打印结果： [20. 30. 40. 50.] [20 30 40] 矩阵乘法 12345678910import numpy as npA = np.array( [[1,1], [0,1]] )B = np.array( [[2,0], [3,4]] )print (A)print (B)print (A*B)#对应位置元素的乘积print (A.dot(B))#矩阵乘法 表示方法1print (np.dot(A, B)) #矩阵乘法 表示方法2 打印结果： [[1 1] [0 1]] [[2 0][3 4]] [2 0][0 4] [[5 4][3 4]] [5 4][3 4] Numpy 中数组和矩阵的乘法 5.Numpy 用法4Numpy 中的运算 12345import numpy as npB = np.arange(3)print (B)print (np.exp(B))#以e为底的指数函数print (np.sqrt(B))#开方 打印结果： [0 1 2] [1. 2.71828183 7.3890561 ] [0. 1. 1.41421356] 矩阵转置与修改 1234567891011121314151617import numpy as np#Return the floor of the inputa = np.floor(10*np.random.random((3,4))) #创建3行4列的（-1，1）*10之间的矩阵，并进行向下取整print (a)a.shapeprint (a.ravel()) #将矩阵转换成向量print ('------')a.shape = (6, 2)print (a) print (a.T) #进行矩阵转置--行列交换,并未改变a本身print (a)a.resize(2,6)#resize改变数组形状为2行6列---resize对数组本身进行操作print (a)print ('------')b = np.floor(10*np.random.random((3,4)))print (a.reshape(3,-1)) #设置成3行，列数为-1时为默认计算--reshape不改变矩阵本身，只返回修改之后的参数print (a) 打印结果： [[8. 3. 4. 3.][8. 1. 1. 5.][0. 6. 3. 7.]] [8. 3. 4. 3. 8. 1. 1. 5. 0. 6. 3. 7.] ------ [[8. 3.][4. 3.][8. 1.][1. 5.][0. 6.][3. 7.]] [[8. 4. 8. 1. 0. 3.][3. 3. 1. 5. 6. 7.]] [[8. 3.][4. 3.][8. 1.][1. 5.][0. 6.][3. 7.]] [[8. 4. 8. 1. 0. 3.][3. 3. 1. 5. 6. 7.]] ------ [8. 3. 4. 3.][8. 1. 1. 5.][0. 6. 3. 7.] [[8. 4. 8. 1. 0. 3.][3. 3. 1. 5. 6. 7.]] resize和reshape，ravel和flatten的区别 矩阵拼接 1234567891011import numpy as npa = np.floor(10*np.random.random((2,2)))b = np.floor(10*np.random.random((2,2)))print (a)print ('---')print (b)print ('---')print (np.hstack((a,b))) #横着进行拼接--增加样本的特征print (np.vstack((a,b))) #竖着进行拼接--增加样本的数量#np.hstack((a,b)) 打印结果： [[7. 3.] [9. 5.]] --- [[3. 9.][1. 5.]] --- [[7. 3. 3. 9.][9. 5. 1. 5.]] [[7. 3.][9. 5.][3. 9.][1. 5.]] 矩阵切割 12345678import numpy as npa = np.floor(10*np.random.random((2,12)))print (a)print (np.hsplit(a,3)) #按照横着切3份print (np.hsplit(a,(3,4)))#在指定位置进行切割,将第三列与第四列单独切出b = np.floor(10*np.random.random((12,2)))print (b) np.vsplit(b,3) #按照竖着切3份 打印结果： [[4. 5. 4. 8. 6. 1. 1. 8. 6. 8. 7. 1.][2. 9. 3. 1. 2. 5. 9. 9. 6. 0. 1. 1.]] [array([[4., 5., 4., 8.],[2., 9., 3., 1.]]),array([[6., 1., 1., 8.],[2., 5., 9., 9.]]),array([[6., 8., 7., 1.], [6., 0., 1., 1.]])] [array([[4., 5., 4.],[2., 9., 3.]]),array([[8.],[1.]]),array([[6., 1., 1., 8., 6., 8., 7., 1.],[2., 5., 9., 9., 6., 0., 1., 1.]])] [[5. 3.][0. 4.][3. 0.][2. 5.] [2. 7.][6. 2.][9. 0.] [4. 0.][6. 4.][4. 9.][5. 6.] [1. 7.]] [array([[5., 3.], [0., 4.],[3., 0.],[2., 5.]]),array([[2., 7.], [6., 2.],[9., 0.], [4., 0.]]),array([[6., 4.],[4., 9.],[5., 6.],[1., 7.]])] 矩阵赋值1 ‘=’ 1234567a = np.arange(12)b = ab is ab.shape = 3,4print a.shapeprint id(a)#a与b指向的区域相同，改变任意一个都会对指定区域进行修改print id(b) 打印结果： (3, 4) 82691200 82691200 矩阵赋值2 ‘view’ 12345678c = a.view() #浅复制print (c is a) #c和a是两个不同的元素c.shape = 2,6#print a.shapec[0,4] = 1234 #但是c可以对a的值进行修改aprint id(a)print id(c)#指向不同 但是共用值 矩阵赋值3 ’copy‘ 12345d = a.copy() #指向不同 且值不公用d is ad[0,0] = 9999print d print a 6.Numpy 用法4矩阵中最大值的操作 123456789import numpy as npdata = np.sin(np.arange(20)).reshape(5,4)print (data)ind = data.argmax(axis=0)print (ind) #以列为单位，找到所在列的最大值所在的下标print (data.shape[1])data_max = data[ind, range(data.shape[1])] #找到每列的最大值，以行数和【列数递增】print (data_max)all(data_max == data.max(axis=0)) 关于矩阵扩展 12345import numpy as npa = np.arange(0, 40, 10)print (a)b = np.tile(a, (3, 5)) #扩展，行成原来的3倍，列成原来的5倍print (b) 打印结果： [0 10 20 30] [[ 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30][0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30][0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30]] True 排序操作 1234567891011import numpy as npa = np.array([[4, 3, 5], [1, 2, 1]])print (a)b = np.sort(a, axis=1)print (b)a.sort(axis=1)print (a)a = np.array([4, 3, 1, 2])j = np.argsort(a)#从小到大排序时的索引print (j)print (a[j])#求出排序完之后的结果 打印结果： [[4 3 5][1 2 1]] [[3 4 5][1 1 2]] [[3 4 5][1 1 2]] [2 3 1 0] [1 2 3 4] —–end 结语：终于结束了，无脑的copy]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python学习之基础语法]]></title>
    <url>%2F2019%2F03%2F06%2Fp3%2F</url>
    <content type="text"><![CDATA[前言：距离上一次博客已经是电脑坏之前了，电脑修修，加上自己对于配置的蜜汁拖延以及配的时候总会有各种各样的问题【你确定不是你的问题？】 emmm ，反正不论如何，这次算是配好了！而且比上次配的更全面！【也算是进步吧！安慰一下自己….】 然后最近呢，除了效率低下以外就是还是在不断的探索如何更好地平衡学习与运动、朋友和男朋友，当然啦，这不是我不学习的理由。 英语呢，最近总是背的很慢【同学你背快过？】好吧，今天呢，回顾了一下UNIT ONE【回顾 or 从头学习？】，还有高数的1.3和1.4，emmm你没看错，10多天过去了，我还在高数才刚刚开始的阶段… 然后呢，学了Numpy还有就是终于配置好你了！闲话太多…我们来看我最近学习的Python吧…！ —————-分界线—————- 1. Python 小介绍Python 是面向对象的、解释型计算机程序设计语言。 目前用Python实现的网站有：雅虎地图、谷歌、YouTube、豆瓣等。 变量命名规则： ​ 首字母：字母/下划线 ​ 字符：字母、下划线、数字 ​ 区分大小写 关于注释：多行注释需要在每一行增加‘#’（eclipse中快捷键为：ctrl+/） 关于编码：在代码中出现中文字符的需要在开头增加coding=gbk 2. Python 数据类型Python 的数据类型主要有：数字（Number）、字符串（String）、列表（List）、元组（Tuple）、字典（Dictionary）。 ①数字（Number）其中数字类型中，主要包含int、long、float、complex（复数）【形如：a+bj / complex(a,b)】 PS.在整型计算中，/ 表示一般除法，而// 表示整除。 ②字符串（String）1.单引号、双引号、三引号​ 单引号与双引号可以进行互换 ​ 三引号可以同时打印多行 PS.换行符为 \n 2.字符串不可变​ 一旦字符串进行创建就不可再变 3.Format操作字符串​ 123age = 3name = 'Tom'print ('&#123;0&#125; was &#123;1&#125; years old'.format(name,age)) 打印出Tom was 3 years old 4.联合字符串​ 1print (name+'was'+str(age)+'years old') 打印出Tom was 3 years old ③列表（List）1.列表内部元素列表内部的元素可以有多种数据类型 12list1 = [1,3,5,7]list2 = ['1',1] 2.列表下标 3.列表常用函数123456789101112131415list1 = [1,'a',2] print ('the list is '+str(list1)) #list1 中的元素格式不同，需要将其进行强制类型转换print (list1)print (list1[1]) #打印第二个元素print (list1[0:2]) #打印第一个、第二个元素，【左闭右开】list1[2] = 5 #将list1 进行更新print (list1)del list1[1] #删除list1 中的第二个元素print (list1)print (len(list1)) #得到list1 的长度print (list1 + [4,5]) #连接list1 与[4,5]print (['Hello']*4) #重复打印为['Hello','Hello','Hello','Hello']print (3 in [1,2,3]) #检验3 是否在列表中print (list1[-2]) #打印倒数第二个元素print (list1[1:]) #从第二个元素开始打印到最后一个元素 4.列表操作函数12345cmp (list1,list2) #比较列表中的元素len (list1)max (list1)min (list1)list (seq) #将元组转换成列表 5.列表操作方法123456789list.append(obj) #在列表末尾添加新的对象list.count(obj) #统计某个元素在列表中的出现次数list.extend(seq) #在列表末尾中一次追加另一个序列中的多个值（用新列表扩展成原来的列表）list.index(obj) #从列表中找出某个值第一次的索引位置list.insert(index,obj) #将对象插入列表list.pop(obj = list[-1]) #移除列表中的某一个元素（默认最后一个元素，并返回该元素的值）list.remove(obj) #移除列表中的某一个值的第一个匹配项list.reverse() #反向列表中的元素list.sort([func]) #对原列表进行排序 ④元组（Tuple）一旦创建就不可更改 12tuple1 = (1,3,5,7,9)print (tuple1[1]) 不可更新与局部删除元素，但是可整体删除 常用函数与列表常用函数相似 元组与列表的不同 1.元组修改123456tuple1 = (2,) #只有一个元素的元组表示方法mix_tuple = (1,2,['a','b']) print (str(mix_tuple)) #类型不同需要进行强制类型转换mix_tuple[2][0] ='c' #将元组中的第三个元素（列表）中的第一个值修改为‘c’mix_tuple[2][1] ='d'print (str(mix_tuple)) 2.元组更新、增加与删除Tuple 不能更新元素的增加、修改与删除 可删除整个 3.Tuple的好处-Tuple操作速度更快 Tuple 比 List 操作速度快，如一个常量集只需要不断遍历，用Tuple更佳 -写保护 Tuple 可以对不需要修改的数据进行写保护 必须要修改时，可以从元组转换成列表，再进行修改 ⑤字典（Dictionary） 键 键值 Key Value 12345678dic1 = &#123;'Tom':123,1:456,'B':789&#125; #Key和Value的值可以为任意格式mix_dic = &#123;'Tom':'boy',11:23:5&#125;print (str(dic(['Tom']))) #打印时需要进行强制类型转换dic1 ['Tom'] = 999 del dic1['Tom'] #删除对应值dic1.clear() #清空字典del dic1 #删除整个字典dic2 =&#123;'name' = 'A','age' = 5,'name' = 'B'&#125; #只有唯一的键 3. Python 函数① 定义def定义函数 ② 返回值返回值可以有，也可以没有 ③ 变量全局变量：位于函数外部或global x 局部变量：位于函数内部 ④ 函数参数 默认参数 一旦开始用默认参数，则后面都为默认参数，以便于一一对应 关键字参数 选择性对参数进行传值 VarArgs参数 不必指明传递的参数个数 1234567def func(a,b=4,c=8) print ('a is'a,'b is'b,'c is'c) func(13,17) #a=13,b=17,c=8func(123,c = 24) #a=123,b=4,c=24func(c = 48,a = 80) #a=80,b=4,c=48func(a,b=2) #在使用缺省参数后，对于函数的必填参数必须在前，默认参数在后func(a=2,b) 默认参数 12345def a(f,*nums,**words) #*nums 相当于一个元组且不指明长度，**words有关键字传入的参数进行对应 print ('f:'+str(f)) print ('nums:'+str(nums)) print ('words:'+str(words))print ('hello',1,2,3,4,word = 'python',another_word = 'java') 1234#打印结果f:hellonums:(1,2,3,4)words:&#123;'another_word':'java','word':'python'&#125; 4. Python控制流① 循环语句1.ifif…elif…else 2.for12345a = &#123;'Tom':111,'Jane'：222&#125;for i in a: print (i) #打印Key print (a[i]) #打印Value print (i,a[i]) for i in range(1,4) #i=1,2,3 3.while直到条件不符合直接跳出循环 ② break语句跳出整个循环 ③ continue语句跳出当前循环的剩余部分并重新进入新的循环 ④ pass语句直接忽略当前，继续执行之后的内容 123456789a = [0,1,2]for i in a: if not i: continue print (i) #打印出1、2for i in a: if not i: pass print (i) #打印出0、1、2 5. Python输入输出 输入 input() 输出 print() 6. Python读写文件(I/O)写文件 1234f = open('sen.txt','w') #创建文件打开并写入文件，文件默认存放当前工作目录【也可加绝对路径】，‘w’写模式a = 'nihao'f.write(a) #写入a的值f.close 读文件 1234567f = open('sen.txt')while True: line = f.readline() #每次读取一行的内容转换成string格式并且赋值给line if len(line) ==0: #当前行内容为空是，表示输出完成【可输出回车】 break print(line)f.close 7. Python错误与异常123456while True: try: x = int(input('Please enter a number')) break except ValueError: print ('Not valid input,try again') 执行说明 1.执行 try 语句下的代码 2.是否出现异常，无异常则except语句内容被忽略；有异常，则可以分为属于except定义的异常，try后的异常代码被忽略，直接跳至except语句执行；否则程序将执行外围一层的try语句，如果异常没有被处理，将产生unhandled exception的错误 8. Python面向对象编程类：现实世界中一些事物的封装（如：学生） ​ 类含有属性（如：名字、成绩） 引用：通过引用对类的属性和方法进行操作 实例化：创建一个类的具体实例对象（如：张三） 具体实例 Student类 123456789class Student: def __init__(self,name,grade): #构造函数，每次实例化类都会调用 self.name = name self.grade = grade def introduction(self)： print('My name is :'+self.name) print('My grade is :'+str(self.grade)) def improve(self,amount): self.grade+=amount 实例引用 1234jim = Student('jim',86)jim.introduction()jim.improve(10)jim.introduction() 9. Python装饰器​ 在原来函数的主体上加入一些小细节 12345678910111213141516def add_candles(cake_func): def insert_candles(): return cake_func()+'candles' return insert_candlesdef make_cake(): return "cake"①gift_func = add_candles(make_cake)print (make_cake())print (gift_func())②make_cake = add_candles(make_cake)③@add_candlesdef make_cake(): return cake_func()+'add candles']]></content>
      <categories>
        <category>Python学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用Github Pages搭建博客]]></title>
    <url>%2F2019%2F02%2F23%2Fp1%2F</url>
    <content type="text"><![CDATA[写在前面： ​ 拖拖拉拉的假程序员，终于要开始自主学习了，之前一年的时间，大部分用来划水和适应，但是终究还是要面临毕业，面对考研/工作的选择，我选择了前者，但是专业知识和技能的薄弱以及结合专业的特点让我有了开始写个人博客的念头，拖延症的自己，终于在返校的第二天开始摩拳擦掌的开了博客，希望此博客能够常常更新，不仅仅作为平时学习的记录，同时也是考研的记录，希望19年能够是有所成长的一年。 一、开始搭建Github Pages1.前言 博客那么多，为啥我要自己搭一个？ 哈哈哈，请先让我大笑一下，这个就好像是一个专栏采访，那么我现在认真回答一下（戏精…）。①其实本来是想和同学一起学做个人博客的，但是目前考虑到时间成本以及学习做记笔记的刚需，我想我还是先采用Github Pages这个成熟的项目；②而且每天都有颜色展示自己的工作进度，还是具有一定督促的（朋友，希望你经常来看看你的BusydeerZ；③之前同学有用同款，我也就心动想借鉴借鉴（抄袭！）。 总而言之，一句话，就是想学习一下怎么更好地记笔记然后好好的做一下记录，记录一下自己的成长。 2.起步1.注册Github 首先进入Github 官网进行注册，注册完成登陆。 2.创建仓库 登陆后，在个人首页找到 New repositor （新存储库）并按照如下图所示进行创建新仓库 3.开启Github Pages 进入设置 找到Github Pages 以 用户名+.github.io 默认开始GitHub Pages 选择主题 设置完毕后，可以通过 用户名.github.io访问自己的博客如（busydeerz.github.io） 二、Hexo安装 Hexo是一个快速、简洁且高效的博客框架。 官网：https://hexo.io/zh-cn/(视频教程+文档 还是非常靠谱的) 具有以下四个特点： 超快速度 支持Markdown 一键部署 丰富的插件 1.Node.js 和 Git 安装 在安装Hexo之前需要安装Node.js以及Git 可按照如下教程进行安装 Node.js 安装教程 Git 安装教程 2.Hexo安装在需要安装Hexo的目录下，新建文件夹并右键选择 Git Bash Here ，输入 1$ npm install hexo-cli -g 等待安装完毕，输入 hexo命令来查看是否安装成功，如下图所示即为安装成功。 初始化 Hexo 输入 1$ hexo init hexo 初始化成功后出现一个名为 hexo 的文件夹 然后进入 hexo 目录 cd hexo 安装依赖文件 npm install 部署形成文件 hexo generate可以缩写成hexo g 开启hexo服务 hexo server可以缩写成hexo s 成功开启服务，可以打开浏览器输入 http://localhost:4000/查看默认博客，如下图所示 三、配置GitHub Pages1.设置SSH Key可按照此教程进行设置Github 设置SSH Key 2.将本地 hexo 项目托管到Github打开先前hexo初始化的目录，找到根目录下的 _config.yml文件，打开并找到最后的deploy属性，加入代码： 123type: gitrepository: gitgit@github.com:用户名/用户名.github.io.gitbranch: master 3.安装 hexo-deployer-git 插件npm install hexo-deployer-git --save 每次修改本地主题，都需要执行以下代码，部署到github上 hexo clean hexo generator #简写成hexo g hexo deploy #简写成hexo d 完成以上步骤就可以将hexo初始的界面部署到Github Pages上 四、基础配置与主题安装1.基础配置 找到根目录的 _config.yml文件，修改里面的关键信息 1234567title: Dyroad的探索之旅subtitle:description: 本博客旨在在记录分享Dyroad学习的过程。keywords: hexoauthor: Dyroad Chenglanguage: zh-Hanstimezone: //默认按照电脑时区 2.主题安装安装主题 发现自己的博客太简单了，琢磨着换一个主题，选定的主题为NexT 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启动NexT主题 打开根目录的_config.yml,找到theme字段，将其只修改为next 验证主题 注意：每次切换主题后、验证主题之前都需要清除Hexo的缓存 hexo clean //清除缓存 验证:启动Hexo本地服务器 hexo s 运行http://localhost:4000查看博客是否切换到指定主题。 3.主题设定可以按照如下教程进行NexT主题修改 NexT主题修改教程 五、写作新建一篇文章 hexo new 文章名 //新建文章 hexo new page 页面名 //新建页面 hexo g -d //部署 hexo s 最后 第一篇博客纰漏难免，忘见谅！（写不动了，草草结尾！见谅！） 全文参考： ​ 我是如何利用Github Pages搭建起我的博客，细数一路的坑 ​ Hexo免费搭建一个属于自己的博客 ​ Hexo的Next主题详细配置 ​ github-如何设置SSH Key 关于图片不能显示！ 很开心的放截图！ 结果不能显示？？？我？？？ 万能百度！ hexo生成博文插入图片【转】 hexo博客图片问题 hexo本地与github不同步的解决方案 ERROR Deployer not found: git ​]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
</search>
